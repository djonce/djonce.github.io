<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>泽柏</title>
    <description>欢迎来到我的个人站~</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 05 Nov 2022 22:23:48 +0800</pubDate>
    <lastBuildDate>Sat, 05 Nov 2022 22:23:48 +0800</lastBuildDate>
    <generator>Jekyll v4.3.1</generator>
    
      <item>
        <title>事件循环（Event Loop）promise、setTimeout、async的先后执行顺序</title>
        <description>
&lt;p&gt;javaScript 的特点就是&lt;strong&gt;单线程&lt;/strong&gt;，在这个线程中拥有唯一的一个事件循环。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;JS 分为同步任务和异步任务，同步任务都在主线程上执行。前一个任务执行完毕之后，执行后一个任务，形成一个&lt;strong&gt;执行栈&lt;/strong&gt;；&lt;/li&gt;
  &lt;li&gt;主线程之外，事件触发线程管理着一个任务队列，异步任务会被主线程挂起，不会进入主线程，而是进入任务队列。只要异步任务有了运行结果，就会在队列任务中放置一个事件；&lt;/li&gt;
  &lt;li&gt;一旦执行栈中所有的同步任务执行完毕后，系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;为什么 JS 是单线程的？？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;JS 的主要用途就是与用户交互，操作 DOM，假如 JS 同时有两个线程，一个线程中在某个 DOM 节点上添加内容，另一个线程需要执行删除该节点操作，就会产生冲突。&lt;/p&gt;

&lt;p&gt;事件循环机制告诉我们 JavaScript 的执行顺序。&lt;/p&gt;

&lt;p&gt;单线程意味着所有任务都需要排队，前一任务结束，才会执行后一个任务，如果前一个任务耗时很长，后一个任务就不得不一直等着。&lt;/p&gt;

&lt;p&gt;JS 引擎执行异步代码不用等待，是因为有事件队列和事件循环。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;事件循环&lt;/strong&gt;是指主线程重复从事件队列中取消息、执行的过程。指整个执行流程。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;事件队列&lt;/strong&gt;是一个存储着待执行任务的序列，其中的任务严格按照时间先后顺序执行，排在队头的任务会率先执行，而排在队尾的任务会最后执行。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://oss.19ba.cn/public/20221031/euk498as.png&quot; alt=&quot;1313634-20190727155718269-1808948786.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;事件队列：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一个线程中，事件循环是唯一的，但是任务队列可以有多个；&lt;/li&gt;
  &lt;li&gt;任务队列又分 macro-task(宏任务)和 micro-task(微任务)；&lt;/li&gt;
  &lt;li&gt;macro-task 包括：script（整体代码）、setTimeout、setInterval、setImmediate、I/O、UI rendering；&lt;/li&gt;
  &lt;li&gt;micro-task 包括：process.nextTick, Promise, Object.observe(已废弃), MutationObserver(html5 新特性)&lt;/li&gt;
  &lt;li&gt;setTimeout/Promise 等称为任务源，而进入任务队列的是他们制定的具体执行任务；&lt;strong&gt;来自不同任务源的任务会进入到不同的任务队列&lt;/strong&gt;，其中 setTimeout 与 setInterval 是同源的；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;宏任务可以理解成每次执行栈执行的代码就是一个宏任务。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;事件循环运行机制&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;（1）执行一个宏任务（栈中没有就从事件队列中获取）&lt;/p&gt;

&lt;p&gt;（2）执行过程中如果遇到微任务，就将它添加到微任务的任务队列中；&lt;/p&gt;

&lt;p&gt;（3）宏任务执行完毕后，立即执行当前微任务队列的所有微任务；&lt;/p&gt;

&lt;p&gt;（4）当前微任务执行完毕，开始检查渲染，然后 GUI 线程接管渲染；&lt;/p&gt;

&lt;p&gt;（5）渲染完毕后，JS 线程继续接管，开始下一个宏任务。&lt;/p&gt;

&lt;p&gt;例：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;                 async function async1() {
                     console.log(&quot;async1 start&quot;);  //(2)
                     await  async2();
                     console.log(&quot;async1 end&quot;);   //(6)
                 }
                 async  function async2() {
                     console.log( &apos;async2&apos;);   //(3)
                 }
                 console.log(&quot;script start&quot;);  //(1)
                 setTimeout(function () {
                     console.log(&quot;settimeout&quot;);  //(8)
                 },0);
                 async1();
                 new Promise(function (resolve) {
                     console.log(&quot;promise1&quot;);   //(4)
                     resolve();
                 }).then(function () {
                     console.log(&quot;promise2&quot;);    //(7)
                 });
                 console.log(&apos;script end&apos;);//(5)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;先按顺序执行同步代码   从‘script start‘开始，&lt;/p&gt;

&lt;p&gt;执行到 setTimeout 函数时，将其回调函数加入队列(此队列与 promise 队列不是同一个队列，执行的优先级低于 promise。&lt;/p&gt;

&lt;p&gt;然后调用 async1()方法，await async2();//执行这一句后，输出 async2 后，await 会让出当前线程，将后面的代码加到任务队列中，然后继续执行 test()函数后面的同步代码&lt;/p&gt;

&lt;p&gt;继续执行创建 promise 对象里面的代码属于同步代码，promise 的异步性体现在 then 与 catch 处，所以 promise1 被输出，然后将 then 函数的代码加入队列，继续执行同步代码，输出 script end。至此同步代码执行完毕。&lt;/p&gt;

&lt;p&gt;开始从队列中调取任务执行，由于刚刚提到过，setTimeout 的任务队列优先级低于 promise 队列，所以首先执行 promise 队列的第一个任务，因为在 async 函数中有 await 表达式，会使 async 函数暂停执行，等待表达式中的 Promise 解析完成后继续执行 async 函数并返回解决结果。&lt;/p&gt;

&lt;p&gt;所以先执行 then 方法的部分，输出 promise2，然后执行 async1 中 await 后面的代码，输出 async1 end。。最后 promise 队列中任务执行完毕，再执行 setTimeout 的任务队列，输出 settimeout。&lt;/p&gt;

&lt;p&gt;setTimeout(fn,0)的含义是指某个任务在主线程最早可得的空闲时间执行。它在“任务队列”的尾部添加一个事件，因此要等到同步任务和“任务队列”现有的时间处理完才会得到执行。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;按照事件循环机制分析以上代码运行流程：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;首先，事件循环从宏任务(macrotask)队列开始，这个时候，宏任务队列中，只有一个 script(整体代码)任务；当遇到任务源(task source)时，则会先分发任务到对应的任务队列中去。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;然后我们看到首先定义了两个 async 函数，接着往下看，然后遇到了 `console` 语句，直接输出 `script start`。输出之后，script 任务继续往下执行，遇到 `setTimeout`，其作为一个宏任务源，则会先将其任务分发到对应的队列中。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;script 任务继续往下执行，执行了 async1()函数，前面讲过 async 函数中在 await 之前的代码是立即执行的，所以会立即输出`async1 start`。&lt;br /&gt;
遇到了 await 时，会将 await 后面的表达式执行一遍，所以就紧接着输出`async2`，然后将 await 后面的代码也就是`console.log(‘async1 end’)`加入到 microtask 中的 Promise 队列中，接着跳出 async1 函数来执行后面的代码。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;script 任务继续往下执行，遇到 Promise 实例。由于 Promise 中的函数是立即执行的，而后续的 `.then` 则会被分发到 microtask 的 `Promise` 队列中去。所以会先输出 `promise1`，然后执行 `resolve`，将 `promise2` 分配到对应队列。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;script 任务继续往下执行，最后只有一句输出了 `script end`，至此，全局任务就执行完毕了。&lt;br /&gt;
根据上述，每次执行完一个宏任务之后，会去检查是否存在 Microtasks；如果有，则执行 Microtasks 直至清空 Microtask Queue。&lt;br /&gt;
因而在 script 任务执行完毕之后，开始查找清空微任务队列。此时，微任务中， `Promise` 队列有的两个任务`async1 end`和`promise2`，因此按先后顺序输出 `async1 end，promise2`。当所有的 Microtasks 执行完毕之后，表示第一轮的循环就结束了。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;6.  第二轮循环依旧从宏任务队列开始。此时宏任务中只有一个 `setTimeout`，取出直接输出即可，至此整个流程结束。&lt;/p&gt;
</description>
        <pubDate>Mon, 31 Oct 2022 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2022/10/event-looppromisesettimeoutasync/</link>
        <guid isPermaLink="true">http://localhost:4000/2022/10/event-looppromisesettimeoutasync/</guid>
        
        
      </item>
    
      <item>
        <title>react h5 template</title>
        <description>
&lt;p&gt;##&lt;/p&gt;
</description>
        <pubDate>Thu, 27 Oct 2022 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2022/10/react-h5-template/</link>
        <guid isPermaLink="true">http://localhost:4000/2022/10/react-h5-template/</guid>
        
        
      </item>
    
      <item>
        <title>js预编译</title>
        <description>
&lt;h2 id=&quot;预编译&quot;&gt;预编译&lt;/h2&gt;

&lt;p&gt;预编译简单理解就是，在代码执行前一刻发生的事情。预编译的过程，也就是 GO 和 AO 创建的过程。&lt;/p&gt;

&lt;h3 id=&quot;go&quot;&gt;GO&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;-&amp;gt; var -&amp;gt; function -&amp;gt; 执行&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;创建 GO（Global Object）对象；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;1、寻找变量声明作为 GO 的属性名，并赋值为 undefined；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;2、寻找函数声明，放入作为 GO 的属性，并赋值为其函数体。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;ao&quot;&gt;AO&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;var 和形参 -&amp;gt; 赋值 -&amp;gt; function -&amp;gt; 执行&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1、再函数被调用之前，创建 AO（Activation Object）对象，又叫执行期上下文；(上下文是唯一的，一个函数被多次被调用时会创建多个上下文)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;2、寻找形式参数和变量声明作为 AO 的属性名，并赋值为 undefined；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;3、传入实际参数的值；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;4、在函数体内寻找函数声明，放入作为 AO 的属性，并赋值为其函数体。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;实例&quot;&gt;实例&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function test() {
  console.log(b);
  if (a) {
    var b = 100;
  }
  console.log(b);
  c =  234;
  console.log(c);
}

var a;
test();
a = 10;
console.log(c);


-----------
GO = {
  // 1、var  2、function 3、 执行；
  a: undefined,
  test: fn,
  c: 234
}

AO = {
  // 1、var和形参  2、赋值 3、function 4、执行；
  b: undefined
}

-&amp;gt; undefined
-&amp;gt; undefined
-&amp;gt; 234
-&amp;gt; 234

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Thu, 27 Oct 2022 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2022/10/js-precompiled/</link>
        <guid isPermaLink="true">http://localhost:4000/2022/10/js-precompiled/</guid>
        
        <category>js</category>
        
        
      </item>
    
      <item>
        <title>React创建更新的方式</title>
        <description>
&lt;p&gt;&lt;strong&gt;三种更新方式&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;reactdomrenderhydrate&quot;&gt;ReactDOM.render||hydrate&lt;/h2&gt;

&lt;h2 id=&quot;setstate&quot;&gt;setState&lt;/h2&gt;

&lt;h2 id=&quot;forceupdate&quot;&gt;forceUpdate&lt;/h2&gt;
</description>
        <pubDate>Thu, 08 Sep 2022 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2022/09/react-create-update/</link>
        <guid isPermaLink="true">http://localhost:4000/2022/09/react-create-update/</guid>
        
        <category>react</category>
        
        
      </item>
    
      <item>
        <title>oprnfire install</title>
        <description>
&lt;h2 id=&quot;安装&quot;&gt;安装&lt;/h2&gt;

&lt;p&gt;Dockerhub上提供了映像的自动构建，这是推荐的安装方法。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker pull nasqueron/openfire:4.7.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;或者，您可以自己构建图像。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker build -t nasqueron/openfire github.com/nasqueron/docker-openfire
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;快速开始&quot;&gt;快速开始&lt;/h2&gt;
&lt;p&gt;使用以下命令启动 Openfire：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run --name openfire -d --restart=always \
  --publish 9090:9090 --publish 5222:5222 --publish 7777:7777 \
  --volume /srv/docker/openfire:/var/lib/openfire \
  nasqueron/openfire:4.7.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;或者，您可以使用示例docker-compose.yml文件来使用Docker Compose启动容器&lt;/p&gt;

&lt;p&gt;将浏览器指向http://localhost:9090并按照设置过程完成安装。HAKK5 的在 10 分钟内构建免费的 Jabber 服务器视频应该可以帮助您进行配置，还可以向您介绍它的一些功能。&lt;/p&gt;

&lt;h2 id=&quot;持久性&quot;&gt;持久性&lt;/h2&gt;
&lt;p&gt;为了让 Openfire 在容器关闭和启动期间保持其状态，您应该在/var/lib/openfire.&lt;/p&gt;

&lt;p&gt;快速启动命令已经安装了一个卷以进行持久化。&lt;/p&gt;

&lt;p&gt;SELinux 用户应该更新主机挂载点的安全上下文，以便它可以很好地与 Docker 配合使用：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mkdir -p /srv/docker/openfire
chcon -Rt svirt_sandbox_file_t /srv/docker/openfire
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Java 虚拟机选项
您可以将选项附加到启动命令以配置 JVM：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run -name openfire -d \
  [DOCKER_OPTIONS] \
  nasqueron/openfire:4.7.1 \
  -XX:+UseConcMarkSweepGC -XX:+CMSIncrementalMode
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;日志&quot;&gt;日志&lt;/h2&gt;
&lt;p&gt;要访问位于 的 Openfire 日志，&lt;strong&gt;/var/log/openfire&lt;/strong&gt;您可以使用docker exec. 例如，如果您想跟踪日志：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker exec -it openfire tail -f /var/log/openfire/info.log
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;维护&quot;&gt;维护&lt;/h2&gt;
&lt;h3 id=&quot;升级&quot;&gt;升级&lt;/h3&gt;
&lt;p&gt;要升级到较新版本：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.下载更新的 Docker 镜像：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker pull nasqueron/openfire:4.7.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;2.停止当前运行的镜像：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker stop openfire
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3.移除停止的容器&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker rm -v openfire
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;4.开始更新镜像&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run -name openfire -d \
  [OPTIONS] \
  nasqueron/openfire:4.7.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;外壳访问&quot;&gt;外壳访问&lt;/h3&gt;
&lt;p&gt;出于调试和维护目的，您可能需要访问容器外壳。如果您使用的是 Docker 版本或更高版本，则可以通过开始使用1.3.0来访问正在运行的容器外壳：bashdocker exec&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker exec -it openfire bash
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Thu, 30 Jun 2022 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2022/06/oprnfire-install/</link>
        <guid isPermaLink="true">http://localhost:4000/2022/06/oprnfire-install/</guid>
        
        
      </item>
    
      <item>
        <title>Calibre电子书管理工具</title>
        <description>
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;

&lt;p&gt;Calibre 是一款强大且易用的电子书本地管理工具，可以在 Windows、macOS 和 Linux 平台集中整理各种格式的电子书……&lt;/p&gt;

&lt;p&gt;https://calibre-ebook.com/zh_CN/download&lt;/p&gt;

&lt;h2 id=&quot;搭建私人电子书平台&quot;&gt;搭建私人电子书平台&lt;/h2&gt;

&lt;h3 id=&quot;1下载镜像&quot;&gt;1、下载镜像&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker pull johngong/calibre-web:latest
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;2创建calibre-web容器&quot;&gt;2、创建calibre-web容器&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; docker create  \
    --name=calibre-web  \
    -p 8083:8083  \
    -p 8080:8080  \
    -v /配置文件位置:/config  \
    -v /书库:/library  \
    -v /自动添加文件夹:/autoaddbooks  \
    -e UID=1000  \
    -e GID=1000  \
    -e CALIBRE_SERVER_USER=用户名  \
    -e CALIBRE_SERVER_PASSWORD=用户密码 \
    --restart unless-stopped  \
    johngong/calibre-web:latest

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;3运行&quot;&gt;3、运行&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker start calibre-web
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;4停止&quot;&gt;4、停止&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker stop calibre-web
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;5删除容器&quot;&gt;5、删除容器&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker rm calibre-web
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;6删除镜像&quot;&gt;6、删除镜像&lt;/h3&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker image &lt;span class=&quot;nb&quot;&gt;rm &lt;/span&gt;johngong/calibre-web:latest
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;参考： https://hub.docker.com/r/johngong/calibre-web&lt;/p&gt;

&lt;h2 id=&quot;管理&quot;&gt;管理&lt;/h2&gt;

&lt;h3 id=&quot;上传书籍&quot;&gt;上传书籍&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;上传数据地址在8080端口&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;用户端&quot;&gt;用户端&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;用户端阅读地址在8083端口&lt;/strong&gt;
&lt;strong&gt;默认管理员登录账号admin，密码admin123, 详细见文档&lt;/strong&gt;&lt;/p&gt;

</description>
        <pubDate>Mon, 27 Jun 2022 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2022/06/calibre/</link>
        <guid isPermaLink="true">http://localhost:4000/2022/06/calibre/</guid>
        
        
      </item>
    
      <item>
        <title>好用的工具网站</title>
        <description>
&lt;h3 id=&quot;图标网站&quot;&gt;图标网站&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://www.iconfont.cn/&quot;&gt;Iconfont&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;制作logo网站&quot;&gt;制作logo网站&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://www.logosc.cn/&quot;&gt;LOGO设计神器&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.logomaker.com.cn/&quot;&gt;标智客&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 17 Jun 2022 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2022/06/some-good-dev-tools/</link>
        <guid isPermaLink="true">http://localhost:4000/2022/06/some-good-dev-tools/</guid>
        
        <category>工具</category>
        
        
      </item>
    
      <item>
        <title>微信小程序开发整理</title>
        <description>
&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;

&lt;h3 id=&quot;常用文档链接&quot;&gt;常用文档链接&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://developers.weixin.qq.com/miniprogram/dev/framework/https://developers.weixin.qq.com/miniprogram/dev/framework/&quot;&gt;微信小程序开发文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/getting-started.html&quot;&gt;微信云开发参考文档&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;小程序注册&quot;&gt;小程序注册&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/wxopen/waregister?action=step1&quot;&gt;微信小程序注册&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;小程序解冻&quot;&gt;小程序解冻&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/cgi-bin/readtemplate?t=forgetpwd/index_tmpl&amp;amp;token=&amp;amp;lang=zh_CN&quot;&gt;微信小程序解冻&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;小程序管理&quot;&gt;小程序管理&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/wxamp/home/guide?lang=zh_CN&amp;amp;token=453053744&quot;&gt;微信小程序管理&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;小程序数据分析&quot;&gt;小程序数据分析&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://wedata.weixin.qq.com/mp2/basic-data/core-data?source=3&quot;&gt;微信小程序数据分析-We分析&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 16 Jun 2022 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2022/06/weixin-miniapp-dev/</link>
        <guid isPermaLink="true">http://localhost:4000/2022/06/weixin-miniapp-dev/</guid>
        
        <category>小程序</category>
        
        
      </item>
    
      <item>
        <title>node project package docker images</title>
        <description>
&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;

&lt;h3 id=&quot;node项目&quot;&gt;node项目&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.
├── Dockerfile
├── _eng.traineddata
├── app.js
├── bin
│   └── www
├── chi_sim_vert.traineddata
├── chi_tra.traineddata
├── eng.traineddata
├── osd.traineddata
├── package-lock.json
├── package.json
├── public
│   ├── javascripts
│   ├── stylesheets
│   └── upload
├── routes
│   ├── index.js
│   ├── ocr.js
│   └── upload.js
└── views
    ├── error.pug
    ├── index.pug
    └── layout.pug

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;简单的脚本&quot;&gt;简单的脚本&lt;/h3&gt;
&lt;p&gt;简单将本地已经安装，可以运行的项目&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;直接打包成镜像&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;FROM node:12

RUN &lt;span class=&quot;nb&quot;&gt;mkdir&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; /usr/ocr/app/

WORKDIR /usr/ocr/app/

COPY &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt; /usr/ocr/app/

EXPOSE 3000

CMD npm start

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;构建镜像&quot;&gt;构建镜像&lt;/h3&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker build &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-t&lt;/span&gt; ocr

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;查看镜像构建成功&quot;&gt;查看镜像构建成功&lt;/h3&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker images
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/docker/node-package-image-1.png&quot; alt=&quot;查看镜像详情&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;启动镜像容器&quot;&gt;启动镜像容器&lt;/h3&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; ocr &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; 3000:3000 ocr
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Wed, 15 Jun 2022 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2022/06/node-project-package-docker-images/</link>
        <guid isPermaLink="true">http://localhost:4000/2022/06/node-project-package-docker-images/</guid>
        
        
      </item>
    
      <item>
        <title>https证书申请</title>
        <description>
&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;

&lt;h3 id=&quot;免费申请https证书&quot;&gt;免费申请HTTPS证书&lt;/h3&gt;
&lt;p&gt;https://zhuanlan.zhihu.com/p/138792764&lt;/p&gt;

&lt;h3 id=&quot;配置&quot;&gt;配置&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;server {
    #SSL 访问端口号为 443
    listen 443 ssl;
    #填写绑定证书的域名
    server_name api.19ba.cn;
    #证书文件名称，容器中的路径
    ssl_certificate /etc/nginx/cert/fullchain.cer;
    #私钥文件名称， 容器中的路径
    ssl_certificate_key /etc/nginx/cert/cert.key;
    ssl_session_timeout 5m;
    #请按照以下协议配置
    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
    #请按照以下套件配置，配置加密套件，写法遵循 openssl 标准。
    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;
    ssl_prefer_server_ciphers on;
    location / {
    #网站主页路径。此路径仅供参考，具体请您按照实际目录操作。
        # root /usr/share/nginx/html;
        # index  index.html;
        proxy_pass http://xxx:3000;
    }

    #access_log  /var/log/nginx/host.access.log  main;

    #error_page  404              /404.html;

    # redirect server error pages to the static page /50x.html
    #
    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   /usr/share/nginx/html;
    }
}


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;多域名配置&quot;&gt;多域名配置&lt;/h3&gt;

&lt;h3 id=&quot;验证配置&quot;&gt;验证配置&lt;/h3&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  openssl s_client &lt;span class=&quot;nt&quot;&gt;-connect&lt;/span&gt; www.example.com:443
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Wed, 15 Jun 2022 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2022/06/https-cert-apply/</link>
        <guid isPermaLink="true">http://localhost:4000/2022/06/https-cert-apply/</guid>
        
        
      </item>
    
  </channel>
</rss>
